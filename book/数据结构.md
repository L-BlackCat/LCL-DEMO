数据
    数据对象（人类，畜类）  性质相同的数据元素的集合（性质相同：拥有同样数目和类型的数据项）
    数据元素（人，猪狗牛羊）    不混淆的情况下  将数据元素称为数据
    数据项（眼耳口鼻，姓名电话等）  最小单位

数据结构：相互之间存在一种或多种特定关系的数据元素的集合

逻辑结构    数据对象中数据元素之间的相互练习
    集合机构：集合结构中的数据元素除了同属一个集合（数据对象）外，没有其他任何联系

    线性结构：线性结构中的数据元素是一对一的关系

    树形结构：属性结构中的数据元素之间存在一种一对多的关系

    图形结构：图形结构的数据元素是对多对的关系

物理结构    数据的逻辑结构在计算机中的存储形式
    顺序存储：把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理是一致的（排队站位，比如数组）

    链式存储：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。通过指针来存放下个元素的地址，通过地址就可以找到相关联的数据元素位置。


数据类型    指一组性质相同的值的集合及定义在此集合上的一些操作的总称
    类型    用来说明变量或表达式的取值范围和所能进行的操作

    原子类型：不可再进行分解的基础类型，包括整形、实型、字符型等。

    结构类型：有若干个类型整合而成，是可以再分解的。例如：整型数组是由若干整型数据组成的

抽象：抽取出食物具有的普遍性的本质，忽略分本质的细节。

抽象数据类型：指一个数字模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性。
一个数据对象、数据对象中各数据元素之间的关系及数据元素的操作。（自定义类）




算法
    算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

    五个基础特性：
        输入
            算法具有零个或多个输入
        输出
            算法至少有一个或多个输出
        有穷性
            算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤都在可接受的时间内完成
        确定性
            算法的每一步骤都具有确定的含义，不会出现二义性。（相同的输入还有唯一的结果）
        可行性
            算法的每一步都必须是可行的，每一步都能够通过执行有限的次数完成。

    要求：
        正确性
        可读性
        健壮性
        时间效率高和存储量低

    算法效率度量方法
        事后统计方法(不采用)    通过设计好的测试程序和算法，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低
            1.编制算法可能很糟糕，浪费时间
            2.时间比较，依赖计算机软件和硬件等环境因素。有时会掩盖算法本身的优劣。
            3.算法的测试数据设计困难，并且程序的运行时间望望还与测试数据的规模有很大的关系，效率高的算法在小的测试数据面前往往得不到体现。

        事前分析估算方法    在计算机程序编制前，依据统计方法对算法进行估算
            消耗时间取决因素：
                1.算法采用的策略、方法（算法好坏的根本）
                2.编译产生的代码质量（软件支持）
                3.问题的收入规模
                4.机器执行指令的速度（硬件性能）
            一个程序的运行时间，依赖于算法的好坏和问题的输入规模

        函数的渐进增长  
            给定两个函数f(n)和g(n),如果存在一个整数N，使得对于所有的n>N，f(n)总比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。

        测试数据结论：
            最高次项的指数大的，函数随着n的增长，结果也会变得增长特别快

            判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。

            某个算法，随着n的增大，它会越来越优于另一算法，或者越来越差于另一算法。

        
        算法时间复杂度
            定义：
                在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。
            算法的时间复杂度，也就是算法的是时间度量。记作：T(n)=O(f(n))。
                它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度（时间复杂度）。

        推导大O阶的方法
            1.用常数1取代运行时间中的所有加法常数
            2.在修改后的运行次数函数中，只保留最高阶项
            3.如果最高阶项存在且不是1，则去除与这个项相乘的常数

        常数阶  O(1)
        线性阶  O(n)
        对数阶  O(logn)
        平方阶  O(n²)
        nlogn阶 O(nlogn)
        立方阶  O(n^3)
        指数阶  O(2^n)

        常见时间复杂度排序（从小到大）:
            O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)
        
        最坏情况和平均情况
            无特殊说明情况下，一般指时间复杂度是指最坏情况下的时间复杂度
